// protoc-gen-clickhouse/main.go
package main

import (
	"log"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const structTemplate = `
// Code generated by protoc-gen-clickhouse. DO NOT EDIT.

package {{.PackageName}}

import (
    "time"
)

type {{.StructName}} struct {
{{- range .Fields }}
    {{.GoName}} {{.GoType}} ` + "`ch:\"{{.CHName}}\"`" + `
{{- end }}
}

func ProtoTo{{.StructName}}(proto *{{.ProtoName}}) *{{.StructName}} {
    return &{{.StructName}}{
    {{- range .Fields }}
        {{.GoName}}: {{.Conversion}},
    {{- end }}
    }
}
`

type Field struct {
	GoName     string
	GoType     string
	CHName     string
	Conversion string
}

type TemplateData struct {
	PackageName string
	StructName  string
	ProtoName   string
	Fields      []Field
}

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, file := range gen.Files {
			if !file.Generate {
				continue
			}
			generateFile(gen, file)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	for _, message := range file.Messages {
		generateStruct(gen, file, message)
	}
}

func generateStruct(gen *protogen.Plugin, file *protogen.File, message *protogen.Message) {
	structName := message.GoIdent.GoName
	fields := make([]Field, 0, len(message.Fields))
	for _, field := range message.Fields {
		goName := field.GoName
		goType := getGoType(field.Desc.Kind())

		chName := strings.ToLower(string(field.Desc.Name()))
		conversion := getConversion(field.Desc.Kind(), "proto."+goName)
		fields = append(fields, Field{
			GoName:     goName,
			GoType:     goType,
			CHName:     chName,
			Conversion: conversion,
		})
	}

	data := TemplateData{
		PackageName: string(file.GoPackageName),
		StructName:  structName,
		ProtoName:   message.GoIdent.GoName,
		Fields:      fields,
	}

	filename := file.GeneratedFilenamePrefix + "_" + strings.ToLower(structName) + ".pb.ch.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	t := template.Must(template.New("struct").Parse(structTemplate))
	if err := t.Execute(g, data); err != nil {
		log.Fatalf("failed to execute template: %v", err)
	}
}

// func mapProtoTypeToClickHouse(field *protogen.Field) string {
// 	switch field.Desc.Kind() {
// 	case protoreflect.StringKind:
// 		return "String"
// 	case protoreflect.BoolKind:
// 		return "UInt8"
// 	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
// 		return "Int32"
// 	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
// 		return "UInt32"
// 	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
// 		return "Int64"
// 	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
// 		return "UInt64"
// 	case protoreflect.FloatKind:
// 		return "Float32"
// 	case protoreflect.DoubleKind:
// 		return "Float64"
// 	case protoreflect.BytesKind:
// 		return "String"
// 	case protoreflect.EnumKind:
// 		return "Enum8"
// 	case protoreflect.MessageKind:
// 		return "String" // You might want to handle nested messages differently
// 	default:
// 		return "String" // Default to String for unknown types
// 	}
// }

func getGoType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "time.Time" // assuming timestamp
	default:
		return "interface{}"
	}
}

func getConversion(kind protoreflect.Kind, fieldName string) string {
	switch kind {
	case protoreflect.MessageKind:
		return "time.Unix(" + fieldName + ", 0)"
	default:
		return fieldName
	}
}
