// protoc-gen-clickhouse/main.go
package main

import (
	"flag"
	"log"
	"path/filepath"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const structTemplate = `
// Code generated by protoc-gen-clickhouse. DO NOT EDIT.

package {{.PackageName}}

{{ if .UsesTime }}
import "time"
{{ end }}


type {{.StructName}} struct {
{{- range .Fields }}
    {{.GoName}} {{.GoType}} ` + "`ch:\"{{.CHName}}\"`" + `
{{- end }}
}

func ProtoTo{{.StructName}}(proto *{{.ProtoName}}) *{{.StructName}} {
    return &{{.StructName}}{
    {{- range .Fields }}
        {{.GoName}}: {{.Conversion}},
    {{- end }}
    }
}
`

var (
	outputPackage = flag.String("output_package", "", "The Go package name for the generated code")
)

type Field struct {
	GoName     string
	GoType     string
	CHName     string
	Conversion string
}

type TemplateData struct {
	PackageName string
	StructName  string
	ProtoName   string
	Fields      []Field
	UsesTime    bool
}

func messageUsesTime(message *protogen.Message) bool {
	for _, field := range message.Fields {
		// fmt.Printf("name: %s %s\n", field.GoIdent.GoName, field.Desc.Kind())
		if field.GoIdent.GoName == "Time" { // Adjust to match your `time.Time` field type
			return true
		}
	}
	return false
}

func main() {
	// var flags flag.FlagSet

	// options := &protogen.Options{
	// 	ParamFunc: flags.Set,
	// }
	// fmt.Printf("starting")

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		outputPackage := ""
		params := gen.Request.GetParameter()

		// Split parameters by comma
		for _, param := range strings.Split(params, ",") {
			// fmt.Printf("param: %s\n", param)
			if strings.HasPrefix(param, "output_package=") {
				outputPackage = strings.TrimPrefix(param, "output_package=")
				// fmt.Printf("Output package set to: %s\n", outputPackage)
				break
			}
		}
		// for _, param := range gen.Request.GetParameter() {
		// 	fmt.Printf("param: %s\n", string(param))
		// 	if strings.HasPrefix(string(param), "output_package=") {
		// 		outputPackage = strings.TrimPrefix(string(param), "output_package=")
		// 		break
		// 	}
		// }
		// fmt.Printf("output_package: %s\n", outputPackage)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f, outputPackage)
		}
		return nil
	})

}

func generateFile(gen *protogen.Plugin, file *protogen.File, outputPackage string) {
	for _, message := range file.Messages {
		generateStruct(gen, file, message, outputPackage)
	}
}

func generateStruct(gen *protogen.Plugin, file *protogen.File, message *protogen.Message, outputPackage string) {

	usesTime := messageUsesTime(message)
	structName := message.GoIdent.GoName
	fields := make([]Field, 0, len(message.Fields))
	for _, field := range message.Fields {
		goName := field.GoName
		goType := getGoType(field.Desc.Kind())

		chName := strings.ToLower(string(field.Desc.Name()))
		conversion := getConversion(field.Desc.Kind(), "proto."+goName)
		fields = append(fields, Field{
			GoName:     goName,
			GoType:     goType,
			CHName:     chName,
			Conversion: conversion,
		})
	}

	data := TemplateData{
		PackageName: outputPackage,
		StructName:  structName,
		ProtoName:   message.GoIdent.GoName,
		Fields:      fields,
		UsesTime:    usesTime,
	}

	basefilename := filepath.Base(file.Desc.Path())
	// filename := file.GeneratedFilenamePrefix + "_" + strings.ToLower(structName) + ".pb.ch.go"
	outName := outputPackage + "/" + basefilename + "_" + strings.ToLower(structName) + ".pb.ch.go"
	// outName := strings.TrimSuffix(filename, filepath.Ext(filename)) + ".ch.go"

	// filename := file.GeneratedFilenamePrefix + "_" + strings.ToLower(structName) + ".pb.ch.go"
	g := gen.NewGeneratedFile(outName, "")
	// g.P("package ", outputPackage)
	// g.P()
	// g.P("// Code generated by protoc-gen-clickhouse. DO NOT EDIT.")
	// g.P()

	t := template.Must(template.New("struct").Parse(structTemplate))
	if err := t.Execute(g, data); err != nil {
		log.Fatalf("failed to execute template: %v", err)
	}
}

// func mapProtoTypeToClickHouse(field *protogen.Field) string {
// 	switch field.Desc.Kind() {
// 	case protoreflect.StringKind:
// 		return "String"
// 	case protoreflect.BoolKind:
// 		return "UInt8"
// 	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
// 		return "Int32"
// 	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
// 		return "UInt32"
// 	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
// 		return "Int64"
// 	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
// 		return "UInt64"
// 	case protoreflect.FloatKind:
// 		return "Float32"
// 	case protoreflect.DoubleKind:
// 		return "Float64"
// 	case protoreflect.BytesKind:
// 		return "String"
// 	case protoreflect.EnumKind:
// 		return "Enum8"
// 	case protoreflect.MessageKind:
// 		return "String" // You might want to handle nested messages differently
// 	default:
// 		return "String" // Default to String for unknown types
// 	}
// }

func getGoType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return "string"
	default:
		return "string"
	}
}

func getConversion(kind protoreflect.Kind, fieldName string) string {
	switch kind {
	// case protoreflect.MessageKind:
	// 	return "time.Unix(" + fieldName + ", 0)"
	default:
		return fieldName
	}
}
